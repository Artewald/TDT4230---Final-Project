#version 450
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct VoxelData
{
    // The range value (size of the voxel) is the pos.w value
    vec4 pos;
    uint material_index;
    uint _0_0_index;
    uint _0_1_index;
    uint _0_2_index;
    uint _0_3_index;
    uint _1_0_index;
    uint _1_1_index;
    uint _1_2_index;
    uint _1_3_index;
};

struct VoxelMaterial {
    vec4 color;
    vec4 specular_color;
    vec3 emissive_color;
    float emissive_strength;
    float smoothness;
    float specular_probability;
};

layout(std430, set = 0, binding = 0) readonly buffer Data {
    VoxelData data[];
} voxel_data;

layout(std430, set = 0, binding = 1) readonly buffer Materials {
    VoxelMaterial data[];
} voxel_materials;

layout(std430, set = 0, binding = 2)  readonly buffer CameraData {
    uint field_of_view;
    float render_distance;
    float aspectRatio;
    float fov_tan;
    mat4 camera_to_world;
    vec4 clear_color;
    uint random_number;
    float image_weight;
    uint frames_since_last_movement;
    vec3 position;
} camera;

layout(set = 1, binding = 0, rgba8) uniform image2D img_out;

struct IntersectionInfo {
    vec3 point;
    vec3 normal;
};

struct VoxelHitInfo {
    bool hit;
    VoxelMaterial material;
    vec3 point;
    vec3 normal;
    float dist;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

// ==================== Const variables ====================
const uint UINT_MAX = -1;
const float INFINITY_F = 1.0/0.0;
const uint AMOUNT_OF_RAY_BOUNCES = 1;

const VoxelMaterial empty_material = VoxelMaterial(vec4(0.0, 0.0, 0.0, 1.0), vec4(0.0, 0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0);

// ==================== Other variables ====================
uint rand_num = camera.random_number;

// ==================== Helper functions ====================

float max_component(vec3 vec) {
    return max(max(vec.x, vec.y), vec.z);
}

float min_component(vec3 vec) {
    return min(min(vec.x, vec.y), vec.z);
}

// Mainly from https://stackoverflow.com/a/167764
float get_random_number() {
    rand_num = (rand_num ^ 61) ^ (rand_num >> 16);
    rand_num = rand_num + (rand_num << 3);
    rand_num = rand_num ^ (rand_num >> 4);
    rand_num = rand_num * 0x27d4eb2d;
    rand_num = rand_num ^ (rand_num >> 15);
    return fract(float(rand_num)/float(UINT_MAX));
}

uint[8] get_children_indices(VoxelData voxel) {
    return uint[8](voxel._0_0_index, voxel._0_1_index, voxel._0_2_index, voxel._0_3_index, voxel._1_0_index, voxel._1_1_index, voxel._1_2_index, voxel._1_3_index);
}

bool is_leaf_node(VoxelData voxel) {
    return voxel._0_0_index == uint(-1) && voxel._0_1_index == uint(-1) &&
           voxel._0_2_index == uint(-1) && voxel._0_3_index == uint(-1) &&
           voxel._1_0_index == uint(-1) && voxel._1_1_index == uint(-1) &&
           voxel._1_2_index == uint(-1) && voxel._1_3_index == uint(-1);
}

int get_pixel_id() {
    ivec2 IDxy = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(img_out);
    return IDxy.x+((IDxy.y-1)*image_size.x);
}

// ==================== Ray functions ====================

vec3 get_random_direction() {
    return normalize(vec3((get_random_number()-0.5)*2, (get_random_number()-0.5)*2, (get_random_number()-0.5)*2));
}

float get_distance(Ray ray, IntersectionInfo hit_info) {
    return length(hit_info.point - ray.origin);
}

bool is_closer(Ray ray, IntersectionInfo hit_info, float closest) {
    return get_distance(ray, hit_info) < closest;
}

IntersectionInfo check_for_intersection(VoxelData voxel, Ray ray, vec3 invertedRayDirection) {
    const vec3 boxMin = voxel.pos.xyz;
    const vec3 boxMax = voxel.pos.xyz + voxel.pos.w;

    if (boxMin.x < ray.origin.x && ray.origin.x < boxMax.x && boxMin.y < ray.origin.y && ray.origin.y < boxMax.y && boxMin.z < ray.origin.z && ray.origin.z < boxMax.z) {
        // The ray originates inside the box
        IntersectionInfo info;
        info.point = ray.origin;
        return info;
    }

    const vec3 tMin = (boxMin - ray.origin) * invertedRayDirection;
    const vec3 tMax = (boxMax - ray.origin) * invertedRayDirection;
    const vec3 t1 = min(tMin, tMax);
    const vec3 t2 = max(tMin, tMax);
    const float tNear = max_component(t1);
    const float tFar = min_component(t2);

    IntersectionInfo info;

    if (tNear > tFar || tFar < 0.0) {
        // No intersection
        info.point = vec3(INFINITY_F);
        return info;
    }

    info.point = ray.origin + ray.direction * tNear;

    vec3 normal = vec3(-sign(ray.direction.x), 0.0, 0.0) * float(tNear == t1.x) 
                    + vec3(0.0, -sign(ray.direction.y), 0.0) * float(tNear == t1.y) 
                    + vec3(0.0, 0.0, -sign(ray.direction.z)) * float(tNear != t1.x && tNear != t1.y);

    info.normal = normal;
    return info;
}

VoxelHitInfo fill_hit_info(VoxelData voxel, IntersectionInfo intersection, Ray ray) {
    VoxelHitInfo data;
    data.material = voxel_materials.data[voxel.material_index];
    data.hit = true;
    data.point = intersection.point;
    data.normal = intersection.normal;
    return data;
}

uint[8] sort_child_voxels_by_distance(VoxelData voxel, Ray ray) {
    // Invert ray direction for faster intersection checks
    vec3 invertedRayDirection = 1.0 / ray.direction;

    // Initialize child indices and distances
    uint[8] child_indices = uint[8](
        voxel._0_0_index, voxel._0_1_index, voxel._0_2_index, voxel._0_3_index,
        voxel._1_0_index, voxel._1_1_index, voxel._1_2_index, voxel._1_3_index
    );
    float[8] distances;

    // Calculate distances
    for (int i = 0; i < 8; ++i) {
        VoxelData child_voxel = voxel_data.data[child_indices[i]];
        IntersectionInfo hit_info = check_for_intersection(child_voxel, ray, invertedRayDirection);
        distances[i] = get_distance(ray, hit_info);
    }

    // Sort child voxels by distance
    for (int i = 0; i < 8; ++i) {
        for (int j = i + 1; j < 8; ++j) {
            if (distances[j] < distances[i]) {
                // Swap distances
                float temp_distance = distances[i];
                distances[i] = distances[j];
                distances[j] = temp_distance;

                // Swap indices
                uint temp_index = child_indices[i];
                child_indices[i] = child_indices[j];
                child_indices[j] = temp_index;
            }
        }
    }

    return child_indices;
}

VoxelHitInfo traverse_and_check_if_intersects(Ray ray) {
    VoxelHitInfo ret_val;
    ret_val.hit = false;
    ret_val.material = empty_material;
    float closest = 9999999999999999999999999.0;
    const vec3 invRaydir = 1.0/ray.direction;
    
    VoxelData temp_voxel = voxel_data.data[voxel_data.data.length()-1];
    IntersectionInfo intersection_info = check_for_intersection(temp_voxel, ray, invRaydir);

    if (intersection_info.point == vec3(INFINITY_F)) return ret_val;

    if (is_leaf_node(temp_voxel)) return fill_hit_info(temp_voxel, intersection_info, ray);
    const uint[8] level_0 = sort_child_voxels_by_distance(temp_voxel, ray);//get_children_indices(temp_voxel);

    // GLSL does not allow for recursive functions, thus it needs to be hard-coded
    #pragma unroll
    //RECURSION_MARKER
    ret_val.dist = closest;
    return ret_val;
}

Ray get_primary_ray(float x_offset, float y_offset) {
    ivec2 IDxy = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 screenSize = imageSize(img_out);

    const vec2 pixel_NCD = vec2((float(IDxy.x)+x_offset+0.5)/float(screenSize.x), (float(IDxy.y)+y_offset+0.5)/float(screenSize.y));
    const vec2 camera_pixel = vec2((2 * pixel_NCD.x - 1) * camera.aspectRatio * camera.fov_tan, (1 - 2 * pixel_NCD.y) * camera.fov_tan);

    const highp vec4 world_search_pos = vec4(vec3(camera_pixel.x, camera_pixel.y, -1.0), 0.0)*camera.camera_to_world;
    highp vec3 current_search_pos = normalize(world_search_pos.xyz);
    current_search_pos.x = -current_search_pos.x;

    return Ray(camera.camera_to_world[3].xyz, normalize(current_search_pos));
}

// Main
void main() {
    ivec2 IDxy = ivec2(gl_GlobalInvocationID.xy);
    vec4 color_in_the_end = vec4(0.0);
    rand_num += get_pixel_id();

    vec3 light = vec3(0.0);
    vec4 color = vec4(1.0);
       
    Ray ray = get_primary_ray(get_random_number(), get_random_number());
    VoxelHitInfo hit = traverse_and_check_if_intersects(ray);
    bool is_specular_bounce = hit.material.specular_probability >= get_random_number();
    light += hit.material.emissive_color * hit.material.emissive_strength * color.rgb;
    color *= mix(hit.material.color, hit.material.specular_color, uint(is_specular_bounce));
    // For some reason the for-loop stopped working on my laptop, but worked with hard coded if loops, so I will have to hard code them.       
    //RAY_BOUNCES_MARKER

    color_in_the_end += vec4(light, 1.0);

    vec4 old_pixel = imageLoad(img_out, IDxy);
    old_pixel = vec4(old_pixel.b, old_pixel.g, old_pixel.r, old_pixel.a);
    color_in_the_end = old_pixel * (1.0 - camera.image_weight) + color_in_the_end * camera.image_weight;
    imageStore(img_out, IDxy, vec4(color_in_the_end.b, color_in_the_end.g, color_in_the_end.r, color_in_the_end.a));
}