#version 450
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct VoxelData
{
    // vec2 pos_xy;
    // The range value (size of the voxel) is the pos_zw.y value this is done to save space
    // vec2 pos_zw;
    vec4 pos;
    uint material_index;
    uint _0_0_index;
    uint _0_1_index;
    uint _0_2_index;
    uint _0_3_index;
    uint _1_0_index;
    uint _1_1_index;
    uint _1_2_index;
    uint _1_3_index;
};

struct VoxelMaterial {
    vec4 color;
    vec3 emissive_color;
    float emissive_strength;
};

layout(set = 0, binding = 0) readonly buffer Data {
    VoxelData data[];
} voxel_data;

layout(set = 0, binding = 1) readonly buffer Materials {
    VoxelMaterial data[];
} voxel_materials;

layout(set = 0, binding = 2)  readonly buffer CameraData {
    uint field_of_view;
    float render_distance;
    float aspectRatio;
    float fov_tan;
    mat4 camera_to_world;
    vec4 clear_color;
} camera;

layout(set = 1, binding = 0, rgba8) uniform image2D img_out; 

struct IntersectionInfo {
    vec3 point;
    vec3 normal;
};

struct Hit {
    bool hit;
    vec4 color;
    vec3 point;
    vec3 normal;
};

struct Ray {
    vec3 origin;
    vec3 direction;
};

// ==================== Const variables ====================
const uint UINT_MAX = -1;
const float INFINITY_F = 1.0/0.0;
const uint AMOUNT_OF_PRIMARY_RAYS = 1;
const uint AMOUNT_OF_RAY_BOUNCES = 1;

const float ATMOSPHERE_HEIGHT = 100*1000;
const float HORIZON_DISTANCE = 1000*1000;
const float FOG_FUNC_CONST = HORIZON_DISTANCE/2.0;
const float PI = 3.14159265359;
const float HALF_PI = 0.5 * PI;

const vec3 sun_dir = normalize(vec3(-2.0, -1.0, 0.0));

const vec4 fog_color = vec4(0.0, 0.35, 0.7, 1.0);

// ==================== Helper functions ====================

float max_component(vec3 vec) {
    return max(max(vec.x, vec.y), vec.z);
}

float min_component(vec3 vec) {
    return min(min(vec.x, vec.y), vec.z);
}

float get_random_number(int seed) {
    return fract(sin(float(seed)) * 43758.5453123);
}

float[AMOUNT_OF_PRIMARY_RAYS] get_random_noise(int seed) {
    float[AMOUNT_OF_PRIMARY_RAYS] noise;
    for (int i = 0; i < AMOUNT_OF_PRIMARY_RAYS; i++) {
        noise[i] = get_random_number(seed);
    }
    return noise;
}

vec4 get_fog_color(Ray ray, IntersectionInfo intersection_info) {
    float dist;
    if (intersection_info.point == vec3(INFINITY_F)) {
        // Calculates where the ray leaves the atmosphere based on the ray direction and using the atmospheric height and horizon distance
        float half_pi = 0.5 * 3.14159265359;
        dist = mix(HORIZON_DISTANCE, ATMOSPHERE_HEIGHT, abs(acos(normalize(ray.direction).y) - HALF_PI))/(HALF_PI);
    } else {
        dist = length(intersection_info.point - ray.origin);
    }
    float fog_factor = (-1.0*tanh((dist-FOG_FUNC_CONST)/FOG_FUNC_CONST)+1.0)/2.0;
    return fog_color*fog_factor + vec4(1.0, 1.0, 1.0, 1.0)*(1.0-fog_factor);
}

vec3 get_random_hemisphere_direction(vec3 normal, int seed) {
    float u = get_random_number(seed) * 2.0 - 1.0;
    float phi = get_random_number(seed+1) * 2.0 * PI;
    float r = sqrt(max(0.0, 1.0-u*u));
    vec3 dir = vec3(r * cos(phi), r * sin(phi), abs(u));
    dir = normalize(dir);
    return dir * sign(dot(normal, dir));
}

// ==================== Ray functions ====================

IntersectionInfo slabs(VoxelData voxel, Ray ray, vec3 invertedRayDirection) {
    const vec3 boxMin = voxel.pos.xyz;//vec3(voxel.pos_xy, voxel.pos_zw.x);
    const vec3 boxMax = voxel.pos.xyz + voxel.pos.w;//vec3(voxel.pos_xy.x + voxel.pos_zw.y, voxel.pos_xy.y + voxel.pos_zw.y, voxel.pos_zw.x + voxel.pos_zw.y);

    vec3 tMin = (boxMin - ray.origin) * invertedRayDirection;
    vec3 tMax = (boxMax - ray.origin) * invertedRayDirection;
    vec3 t1 = min(tMin, tMax);
    vec3 t2 = max(tMin, tMax);
    float tNear = max(max(t1.x, t1.y), t1.z);
    float tFar = min(min(t2.x, t2.y), t2.z);

    IntersectionInfo info;

    if (tNear > tFar || tFar < 0.0) {
        // No intersection
        info.point = vec3(INFINITY_F);
        return info;//false;
    }

    // Calculate intersection point and surface normal
    info.point = ray.origin + ray.direction * tNear;

    vec3 normal = vec3(0.0);
    
    if (tNear == t1.x) {
        normal = vec3(-sign(ray.direction.x), 0.0, 0.0);
    } else if (tNear == t1.y) {
        normal = vec3(0.0, -sign(ray.direction.y), 0.0);
    } else {
        normal = vec3(0.0, 0.0, -sign(ray.direction.z));
    }

    info.normal = normal;
    return info;
}

uint[8] get_children_indices(VoxelData voxel) {
    return uint[8](voxel._0_0_index, voxel._0_1_index, voxel._0_2_index, voxel._0_3_index, voxel._1_0_index, voxel._1_1_index, voxel._1_2_index, voxel._1_3_index);
}

bool is_leaf_node(VoxelData voxel) {
    return voxel._0_0_index == uint(-1) && voxel._0_1_index == uint(-1) &&
           voxel._0_2_index == uint(-1) && voxel._0_3_index == uint(-1) &&
           voxel._1_0_index == uint(-1) && voxel._1_1_index == uint(-1) &&
           voxel._1_2_index == uint(-1) && voxel._1_3_index == uint(-1);
}

float get_fog_factor(float dist) {
    return pow(10.0, -1.0*dist/1000.0);
}

Hit fill_hit_color(VoxelData voxel, IntersectionInfo intersection, Ray ray) {
    Hit data;
    data.color = voxel_materials.data[voxel.material_index].color;
    data.hit = true;
    data.point = intersection.point;
    data.normal = intersection.normal;
    return data;
}

float get_distance(Ray ray, IntersectionInfo hit_info) {
    return length(hit_info.point - ray.origin);
}

bool is_closer(Ray ray, IntersectionInfo hit_info, float closest) {
    return get_distance(ray, hit_info) < closest;
}

Hit voxel_hit(Ray ray) {
    Hit ret_val;
    ret_val.hit = false;
    ret_val.color = get_fog_color(ray, IntersectionInfo(vec3(INFINITY_F), vec3(0.0)));
    float closest = 999999999999999999.0;
    const vec3 invRaydir = 1.0/ray.direction;
    
    // GLSL does not allow for recursive functions, thus it needs to be hard-coded
    VoxelData temp_voxel = voxel_data.data[voxel_data.data.length()-1];
    IntersectionInfo intersection_info = slabs(temp_voxel, ray, invRaydir);

    if (intersection_info.point == vec3(INFINITY_F)) return ret_val;

    if (is_leaf_node(temp_voxel)) return fill_hit_color(temp_voxel, intersection_info, ray);
    const uint[8] level_0 = get_children_indices(temp_voxel);
    //RECURSION_MARKER
    return ret_val;
}

Ray get_primary_ray(float x_offset, float y_offset) {
    ivec2 IDxy = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 screenSize = imageSize(img_out);

    const vec2 pixel_NCD = vec2((float(IDxy.x)+x_offset+0.5)/float(screenSize.x), (float(IDxy.y)+y_offset+0.5)/float(screenSize.y));
    const vec2 camera_pixel = vec2((2 * pixel_NCD.x - 1) * camera.aspectRatio * camera.fov_tan, (1 - 2 * pixel_NCD.y) * camera.fov_tan);

    const highp vec4 world_search_pos = vec4(vec3(camera_pixel.x, camera_pixel.y, -1.0), 0.0)*camera.camera_to_world;
    highp vec3 current_search_pos = normalize(world_search_pos.xyz);
    current_search_pos.x = -current_search_pos.x;

    return Ray(camera.camera_to_world[3].xyz, normalize(current_search_pos));
}

int get_pixel_id() {
    ivec2 IDxy = ivec2(gl_GlobalInvocationID.xy);
    ivec2 image_size = imageSize(img_out);
    return IDxy.x+((IDxy.y-1)*image_size.x);
}

// Main
void main() {
    ivec2 IDxy = ivec2(gl_GlobalInvocationID.xy);
    vec4 color_in_the_end = vec4(0.0);

    float x_offset[AMOUNT_OF_PRIMARY_RAYS] = get_random_noise(get_pixel_id());
    float y_offset[AMOUNT_OF_PRIMARY_RAYS] = get_random_noise(get_pixel_id()*2219011);

    for (int i = 0; i < AMOUNT_OF_PRIMARY_RAYS; i++) {
        Ray ray = get_primary_ray(x_offset[i], y_offset[i]);
        Hit hit = voxel_hit(ray);
        vec4 color = hit.color;
        // For some reason the for-loop stopped working on my laptop, but worked with hard coded if loops, so I will have to hard code them.       
        // for (int j = 0; j < AMOUNT_OF_RAY_BOUNCES; j++) {
        //     if (hit.hit) {
        //         ray = Ray(hit.point + hit.normal, reflect(ray.direction, hit.normal));
        //         hit = voxel_hit(ray);
        //         color *= hit.color;
        //     }
        // }
        //RAY_BOUNCES_MARKER

        color_in_the_end += color * (1.0 / float(AMOUNT_OF_PRIMARY_RAYS));
    }

    imageStore(img_out, IDxy, vec4(color_in_the_end.b, color_in_the_end.g, color_in_the_end.r, color_in_the_end.a));
}